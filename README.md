# Algoritmos de Ordenação

Este repositório contém a implementação de diversos algoritmos de ordenação usando a linguagem de programação C++, desenvolvidos como parte da disciplina de "Projeto de Algoritmos". O programa oferece uma interface que permite ao usuário escolher entre diferentes métodos de ordenação, incluindo Insertion Sort, Bubble Sort, Selection Sort, Shell Sort, Merge Sort, Quick Sort e Heap Sort. Além disso, o usuário pode selecionar o tamanho do conjunto de dados e a distribuição inicial dos elementos, que pode ser ordenada de forma crescente, decrescente ou aleatória.

Tamanhos disponíveis: 10, 100, 1.000, 10.000, 100.000 e 1.000.000;

O principal objetivo deste projeto é analisar e comparar o desempenho relativo de cada algoritmo, considerando diferentes tamanhos de entrada e padrões de distribuição inicial dos dados. Com isso, busca-se compreender as vantagens e desvantagens de cada abordagem, permitindo uma melhor escolha dependendo do cenário de aplicação.

Os experimentos realizados com os algoritmos implementados permitem avaliar o número de operações realizadas, o tempo de execução e o impacto da escolha do algoritmo em diferentes situações, proporcionando uma visão prática sobre a complexidade computacional dos métodos de ordenação.


------ ENGLISH VERSION ------

This repository contains the implementation of various sorting algorithms using the C++ programming language, developed as part of the "Algorithm Design" course. The program provides an interface that allows users to choose between different sorting methods, including Insertion Sort, Bubble Sort, Selection Sort, Shell Sort, Merge Sort, Quick Sort, and Heap Sort. Additionally, users can specify the size of the dataset and the initial distribution of elements, which can be ascending, descending, or random.

Available sizes: 10, 100, 1.000, 10.000, 100.000, and 1.000.000.

The main goal of this project is to analyze and compare the performance of different sorting algorithms by considering various input sizes and initial data distributions. Through this comparison, the project aims to highlight the strengths and weaknesses of each approach, helping to determine the most suitable algorithm for different scenarios.

The experiments conducted with the implemented algorithms allow for an evaluation of the number of operations performed, execution time, and the impact of choosing a specific algorithm under different conditions. This provides a practical understanding of the computational complexity and efficiency of sorting techniques.
